\chapter{Concluzii}

\section{Sinteza contribuțiilor}

Prezentul proiect a implementat, analizat și \textbf{optimizat} algoritmul de compresie Gorilla pentru serii temporale. Principalele contribuții sunt:

\subsection{Implementare completă în Python}

A fost realizată o implementare funcțională a algoritmului Gorilla, incluzând:
\begin{itemize}
    \item Module pentru operații la nivel de bit (\texttt{BitWriter}, \texttt{BitReader});
    \item Compresie delta-of-delta pentru timestamp-uri cu codare variabilă;
    \item Compresie XOR pentru valori în virgulă mobilă cu refolosire de fereastră;
    \item Suport pentru serii univariate și multivariate;
    \item Organizare în blocuri de durată configurabilă (implicit 2 ore).
\end{itemize}

\subsection{Optimizarea algoritmului: Condiția ferestrei de 11 biți}

\textbf{Contribuția originală} a acestui proiect constă în identificarea și implementarea unei optimizări a condiției de refolosire a ferestrei XOR. Algoritmul original Gorilla refolosește fereastra anterioară ori de câte ori aceasta ``încape'' în fereastra curentă. Noi am demonstrat că această decizie nu este întotdeauna optimă.

Optimizarea propusă adaugă verificarea:
\begin{equation}
    M_{anterior} - M_{curent} \leq 11
\end{equation}

Această condiție este \textbf{matematic optimă}: crearea unei ferestre noi costă exact 11 biți (5 pentru leading zeros + 6 pentru lungime), deci merită să o creăm doar dacă economia depășește acest overhead.

\subsection{Documentare teoretică}

Au fost prezentate în detaliu:
\begin{itemize}
    \item Fundamentele matematice ale reprezentării în complement față de 2;
    \item Schema de codare variabilă pentru delta-of-delta (buckets de 1, 9, 12, 16, 36 biți);
    \item Mecanismul XOR și optimizarea prin refolosirea ferestrei de biți;
    \item Analiza matematică a trade-off-ului fereastră veche vs. fereastră nouă;
    \item Structura ierarhică a implementării (3 niveluri: biți, encodere, stocare).
\end{itemize}

\subsection{Validare experimentală extinsă}

Implementarea a fost testată pe \textbf{trei seturi de date} reale:

\begin{table}[h]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Dataset} & \textbf{Puncte} & \textbf{Gorilla Std} & \textbf{Gorilla Opt} \\
\midrule
CPU Load (univariat) & 480 & 2.20x & 2.37x \\
Twitter Volume (univariat) & 15,866 & 6.59x & 6.64x \\
Room Climate (8 variabile) & 68,229 & 4.13x & 4.20x \\
\bottomrule
\end{tabular}
\caption{Rate de compresie obținute}
\end{table}

Toate testele au validat corectitudinea round-trip a compresiei (lossless, bit-perfect).

\section{Rezultatele optimizării}

Optimizarea propusă a demonstrat îmbunătățiri pe \textbf{toate} seturile de date testate:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Dataset} & \textbf{Economie (bytes)} & \textbf{Îmbunătățire} \\
\midrule
CPU Load & 249 B & \textbf{7.14\%} \\
Twitter Volume & 262 B & 0.68\% \\
Room Climate & 21,253 B & 1.79\% \\
\midrule
\textbf{Total} & \textbf{21,764 B} & \textbf{1.77\%} \\
\bottomrule
\end{tabular}
\caption{Îmbunătățirile aduse de varianta optimizată}
\end{table}

\textbf{Observație importantă}: Nu există niciun caz în care varianta standard ar fi mai bună --- optimizarea este \textbf{universal benefică}. Aceasta confirmă corectitudinea analizei matematice.

\section{Concluzii tehnice}

\subsection{Eficiența delta-of-delta}

Compresia timestamp-urilor este extrem de eficientă pentru date cu intervale regulate:
\begin{itemize}
    \item Pentru Twitter (interval perfect de 5 minute): $>$99\% comprimate la 1 bit;
    \item Pentru CPU și Room Climate: $\sim$85\% comprimate la 1 bit;
    \item Media: 2--3 biți per timestamp, față de 64 biți necomprimat.
\end{itemize}

\subsection{Eficiența XOR encoding}

Compresia valorilor depinde de caracteristicile datelor:
\begin{itemize}
    \item Valori constante sau aproape constante: 1 bit (XOR = 0);
    \item Valori cu variație lentă: beneficiază de refolosirea ferestrei (2 + M biți);
    \item Valori cu variație bruscă: necesită fereastră nouă (13 + M biți).
\end{itemize}

\textbf{Optimizarea noastră} reduce ineficiența în cazurile în care fereastra anterioară era semnificativ supradimensionată.

\subsection{Avantajul stocării multivariate}

Pentru serii cu multiple variabile per timestamp:
\begin{itemize}
    \item Un singur stream de timestamp-uri pentru toate variabilele;
    \item Fiecare variabilă menține context XOR propriu;
    \item Economie de $\sim$3.7 MB pentru Room Climate (72 $\rightarrow$ 17 bytes/punct).
\end{itemize}

\section{Limitări identificate}

\subsection{Date cu variabilitate mare}

Algoritmul nu este optim pentru:
\begin{itemize}
    \item Timestamp-uri aleatorii sau foarte neregulate;
    \item Valori care variază drastic între măsurători consecutive;
    \item Date criptate sau comprimate anterior (aspect aleatoriu).
\end{itemize}

\subsection{Overhead pentru serii scurte}

Pentru serii cu foarte puține puncte ($<$100), overhead-ul primelor valori (stocate integral pe 64 biți) domină, reducând eficiența compresiei.

\subsection{Decodare secvențială}

Decomprimarea necesită parcurgerea secvențială de la începutul blocului. Nu există acces aleatoriu la un punct specific fără a decoda toate punctele anterioare din bloc.

\subsection{Implementare interpretată}

Fiind scrisă în Python (limbaj interpretat), implementarea are performanță inferioară unei implementări native. Timpii de compresie observați ($\sim$2.7 secunde pentru 68,229 puncte × 8 variabile) ar putea fi reduși semnificativ într-un limbaj compilat.

\section{Direcții de dezvoltare ulterioară}

\subsection{Optimizări de performanță}

\begin{itemize}
    \item \textbf{Implementare în C/Rust}: Port-area la un limbaj compilat pentru performanță de producție;
    \item \textbf{Paralelizare}: Blocurile independente pot fi comprimate/decomprimate în paralel.
\end{itemize}

\subsection{Funcționalități adiționale}

\begin{itemize}
    \item \textbf{Partial decode}: Decodare doar a unui interval din bloc;
    \item \textbf{Indexare}: Structuri pentru acces rapid la anumite timestamp-uri;
    \item \textbf{Streaming API}: Interfață pentru procesare în flux a datelor;
    \item \textbf{Suport pentru missing values}: Gestionarea explicită a punctelor lipsă.
\end{itemize}

\subsection{Extinderea optimizării}

\begin{itemize}
    \item \textbf{Analiză pe mai multe seturi de date}: Validarea optimizării pe date din alte domenii;
    \item \textbf{Threshold adaptiv}: Investigarea dacă pragul de 11 biți poate fi ajustat dinamic;
\end{itemize}

\section{Concluzii}

Algoritmul Gorilla reprezintă o soluție elegantă și eficientă pentru compresia seriilor temporale. Prin exploatarea inteligentă a proprietăților specifice ale acestui tip de date --- periodicitatea timestamp-urilor și corelația temporală a valorilor --- obține rate de compresie semnificative (2--7x în funcție de date) menținând caracterul lossless.

\textbf{Contribuția principală} a acestui proiect este optimizarea condiției de refolosire a ferestrei XOR, care aduce îmbunătățiri consistente (0.68\%--7.14\%) fără niciun dezavantaj. Această optimizare este \textbf{matematic optimă} și a fost \textbf{validată experimental} pe trei seturi de date diferite.

Implementarea realizată demonstrează fezabilitatea aplicării algoritmului (și a optimizării) pe date reale. Deși Python nu este limbajul optim pentru performanță maximă, claritatea codului a facilitat:
\begin{itemize}
    \item Înțelegerea profundă a algoritmului;
    \item Identificarea oportunității de optimizare;
    \item Validarea corectitudinii prin teste round-trip.
\end{itemize}

Compresia seriilor de timp rămâne un domeniu activ de cercetare, cu aplicații în creștere odată cu proliferarea IoT și a sistemelor de monitorizare distribuite. Optimizarea prezentată în această lucrare demonstrează că algoritmii consacrați pot fi încă îmbunătățiți prin analiză atentă a cazurilor marginale.

\textbf{Recomandare finală}: Varianta optimizată a algoritmului Gorilla ar trebui adoptată în toate implementările, fiind superioară din punct de vedere matematic și confirmat experimental, fără niciun compromis.